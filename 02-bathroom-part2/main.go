package main

import (
	"fmt"
	"reflect"
	"strings"
)

func main() {

	// example steps for tests
	// TODO: Write tests
	// expect 5DB3
	// instructions := []string{
	// 	"ULL",
	// 	"RRDDD",
	// 	"LURDL",
	// 	"UUUUD",
	// }

	// original directions from http://adventofcode.com/2016/day/2
	// final answer to expect = A6B35
	instructions := []string{
		"RUDULRLLUULRURDDRRUDURULLLDRLRLUDDLUDUDDUDRRDUDULDUUULLRULLRLDDLDLDDRLRRRRUDLLDDUULDRLLUDDRRUURLULRRRDLLURRUUDURUDDURLUDDDLUDDUUDUURUDLRDRDRLRDRLDRUDRUUDLRDDRRURDDLRDDRRURDUDDLULLUDRURURRRLRRUDUULULULRRLDLUDUURRLLRUDLLDRDDLRRRULRUDLULDDLLLULDLRUDLLLLRDDLRDRLDRLLRDRRDLRDULULRLLLDRUDRRRUULRUULDRURLUDRURRDLLDLRDLDDDDRRLUDLRRLUUUURDRDDLRRURURRDUULLRLURLURUDDDRDURDUUDRLRLRRLDDLDLDLDDDUDDULURLDDLLRLRRDULUDDLULRLUDDLDLRULUUUDRLDRUDURLUDDRLLRUULDLRRRRDLLLLURULLRDRRUDLUULRRDLLRLRLUDLDDULLDLLRDLDLL",
		"LLUUUUUUDUDRLRDRDLDURRRLLRRLRURLLUURRLLUDUDLULUURUUURDLUDLDDLULLRDLRUULDLRDUDURLLDDUDUDULLUDDUULLLUULRRRLULRURRDLRUDUDDURRRDRUURDURLLULLRULLDRUULLURLDRDUUDDDDDDRRLDRLRRRLULDDUURRLLLLDRURLURDRDRDURUDUURRDUDUDRLLUUDDRLUDDDRDLDLRLDRURRDLLRULDRLLURURRLUULLRLRRURDDRDRUUURUURUUUDLLRRLUDRLDLRLURLDLUDDUDDDLDUDRRLDLRURULRLLRDUULURRRULDLLLRLDDDUURRRRDULLRURRLULULDLRRUDUDDLRUURDLDUDDUDRRDLRRRDUDUUUDLLDDDDLURLURRRUUULLLULRRLLLLLLULDUUDLRUDRRDLRDUUDUDLLRLDLLRUURDUUURUUUDDLLUUDLULDURLULULUUUDRUDULLURRULRULLRDLDDU",
		"RLUUURULLDLRLDUDRDURRDUURLLUDDDUULRRRLRLURDDRUULUDULDUUDDDDUDDDDRUDDLDUUDRUDLRRRLLRDDLLLRLLRUULRUULDDRURRLURRLRLULDDRRRDDURDDRDRDULRUDRUUDULRLLULDLRLLDRULRDDRRDDUDLRLLUDRDRRRLUDULRDLRDDURRUUDDRRUDURRUUUDDRRDUDURLUUDUDUURDDDLURLULLUULULURUDUUDRUDULLUUULURDLDUULLDDLLDULRLRLRDUUURUUDLRLDURUDRLDULLUDLDLLRDUURRDUDURLUUUDLLRRULRLULRLDLLURDURRULRLLRRDUDLLRDRRRRDLUUDRUUUDDLRLUDDDDDDRURRRUUURRDLLRURLDDLLDLRRLLLDRRULRRUDLDRDDRRLULURLLUURURURRRRUUUUURUDURLRLLLULULDLLDLRDRRULUDUDRDRRDRDRRDUDLLLRUDRUDDDULRULRRRDRLRUUUURUDURDUUULLULRUDDULDUUDLDURRD",
		"ULRULDDLDLULLLRRRLRUDDDDDLLDDUDLRRDULUUDRDLRRURDRRLUULRURUDRRULDLLLUDRUUDULULUDDRUDDDRDURRRDRDUUURLRDULUDRDRLDRUDDLLLDRRULUDLUDLDLLRRUDUULULDLDLLUURDLDDLLUUDURLURLLLDRDLDRRLRULUURRDRULRUUURULRRUDDDDLLDLDDLLRRLRRRRDUUDUDLDRDRRURDLRURULDLRDLLLLRUDRLLRDLRLRDURDRUDURRRLRDRDLLRLUDDDDRLRLLDUURRURLUURUULUDLUURDRRUDDLUDUDDDURRDRUDRLRULDULUUUUUUDDUDRUDUUURUDRRDLUDLUUDUULUDURDLDDDLLURRURUUDUDDRRDRLLULULDRLRURRDDDRDUUURDDDRULUDRDDLDURRLDDDLRRRLDDRDURULDLUDLLLURLURRLRRULDLLDDUDRRULDRRRRLURRUULRRRUDLURDLLDLLDULUUDRRLDLLLDRLRUDLUULDLDRUDUDURDRUDRDDDLRLULLUR",
		"LRLUUURRLRRRRRUURRLLULRLULLDLUDLUDRDDRLDLRLULLURDURLURDLLRLDUUDDURRRRLDLLRULLRLDLLUUDRLDDLLDRULDRLLRURDLRURRUDLULLRURDLURRURUDULLDRLLUUULUDRURRUUDUDULUUULRLDDULDRDLUDDUDDDLRURULLDLLLRLLUURDLRUDLLLLDLLRLRUUUDDRUUUUDLDLRDDURLDURUULLLUUDLLLLDULRRRLLDLDRRDRLUDRUDURLLUDLRLLUDUDRDDDRDLRDLRULUULDRLUDLRLDUURLRRLUDDDUUDDDUDRLDLDUDLURUULLDDDURUUULRLUDLDURUUDRDRURUDDUURDUUUDLLDLDLDURUURLLLLRURUURURULRULLRUDLRRUUUUUDRRLLRDDUURDRDRDDDUDRLURDRRRUDLLLDURDLUUDLLUDDULUUDLDUUULLDRDLRURUURRDURRDLURRRRLLUUULRDULDDLDUURRDLDLLULRRLLUDLDUDLUUL",
	}

	// define a struct for neighbouring keys (where 0 is empty)
	type Relationship struct {
		U string
		D string
		L string
		R string
	}

	// Map of the relationship of surrounding keys which will be accessed by field name
	// Using strings since the keycodes can be letters
	// TODO: Would be nice if these map values could be auto-generated instead of manually set
	relationships := map[string]Relationship{
		"1": Relationship{U: "0", D: "3", L: "0", R: "0"},
		"2": Relationship{U: "0", D: "6", L: "0", R: "3"},
		"3": Relationship{U: "1", D: "7", L: "2", R: "4"},
		"4": Relationship{U: "0", D: "8", L: "3", R: "0"},
		"5": Relationship{U: "0", D: "0", L: "0", R: "6"},
		"6": Relationship{U: "2", D: "A", L: "5", R: "7"},
		"7": Relationship{U: "3", D: "B", L: "6", R: "8"},
		"8": Relationship{U: "4", D: "C", L: "7", R: "9"},
		"9": Relationship{U: "0", D: "0", L: "8", R: "0"},
		"A": Relationship{U: "6", D: "0", L: "0", R: "B"},
		"B": Relationship{U: "7", D: "D", L: "A", R: "C"},
		"C": Relationship{U: "8", D: "0", L: "B", R: "0"},
		"D": Relationship{U: "B", D: "0", L: "0", R: "0"},
	}

	// Create variable to store the final doorcode
	doorcode := make([]string, 0)

	// Start at key 5
	currentPosition := "5"

	// Loop through each row of instructions to get the final keycode for that row
	for r, row := range instructions {
		for _, direction := range row {
			// Unlike some other languages, can't access the value of a struct by fieldname
			// using something like this: relationship["U"]. Must use reflection.
			// Examples: https://www.socketloop.com/tutorials/golang-how-to-get-struct-field-and-value-by-name
			keyReflection := reflect.ValueOf(relationships[currentPosition])
			nextKeyCode := keyReflection.FieldByName(string(direction)).String()
			if nextKeyCode != "0" {
				fmt.Println(string(direction), ">>>", nextKeyCode)
				currentPosition = nextKeyCode
			}
		}
		fmt.Println("Key code for row", r, ":", currentPosition)
		doorcode = append(doorcode, currentPosition)
	}

	fmt.Println("FULL DOOR CODE", strings.Join(doorcode, ""))
}
